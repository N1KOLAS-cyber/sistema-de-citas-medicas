rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Colección de usuarios
    match /usuarios/{userId} {
      allow read: if request.auth != null;
      allow write: if request.auth != null && request.auth.uid == userId;
      
      // Subcolección de calificaciones - permitir a cualquier usuario autenticado crear calificaciones
      match /ratings/{ratingId} {
        allow read: if request.auth != null;
        allow create: if request.auth != null;
        allow update, delete: if false; // No permitir editar o eliminar calificaciones
      }
    }
    
    // Colección de citas
    match /citas/{appointmentId} {
      allow read: if request.auth != null && 
        (resource.data.patientId == request.auth.uid || 
         resource.data.doctorId == request.auth.uid);
      
      allow create: if request.auth != null && 
        request.resource.data.patientId == request.auth.uid;
      
      allow update: if request.auth != null && 
        (resource.data.patientId == request.auth.uid || 
         resource.data.doctorId == request.auth.uid);
      
      allow delete: if request.auth != null && 
        resource.data.patientId == request.auth.uid;
    }
    
    // Colección de disponibilidad de médicos
    match /disponibilidad_medicos/{availabilityId} {
      allow read: if request.auth != null;
      // Permitir que cualquier usuario autenticado pueda actualizar la disponibilidad
      // cuando se crea/cancela una cita (marcar como disponible/no disponible)
      allow update: if request.auth != null;
      // Solo el doctor puede crear/eliminar sus propios horarios
      allow create, delete: if request.auth != null && 
        request.resource.data.doctorId == request.auth.uid;
    }
    
    // Colección de consejos médicos - lectura pública para usuarios autenticados
    match /consejos_medicos/{adviceId} {
      allow read: if request.auth != null;
      // Solo permitir escritura a administradores (opcional)
      allow write: if request.auth != null && 
        request.auth.token.email.matches('cs.*@.*');
    }
  }
}

